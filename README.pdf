
1
Jaeden HufnagleNetId: jhufnaglIncluded files:Coordinator.javaMST.javaScript.shHow to Run:Generally, the code needs to be run with the simple initial command for compilation(done to prevent me from submitting a ton of .class files) by writing Javac MST.java then callingJava MST with the arguments -a (animation mode) -n (number of points on the graph) -s (seednumber) -t (number of threads). All arguments are optional and have a default condition.Explanation of how code generally works:So using the given Skeleton code by Professor Scott I made two thread classes for eachunique problem. (i.e Dwyer Helper and Kruskal Helper) The triangulation helper classgenerically works by using first a Semaphore and Lock to make sure the data is operated uponproperly. So, when divide and conquer happens half of the points are fed into the thread (upuntil the limit of threads) at after divide and conquer is done the threads wait for all the others tofinish so the graph can be stitched properly together. (done using join()). Kruskal’s algorithmworks in a different fashion as it doesn’t lend itself as easily to parallelizing. So, the parallelizedversion works by dividing the process of checking for cycles in the graph. So it creates aseparate data structure that each thread can uniquely work on to prevent data races. In anessence, the Kruskal speed up isn’t nearly as significant due to the lack of ability to parallelize ina meaningful manner.Analysis of times:Average runtime graph:
This graph shows the average runtime for threads 1, 2, 4, 6, 8, 12, 24, 32, 48, and 64threads. It’s clear here that the peak runtime seems to be around 24 threads as it has thesmallest time. The reason why the runtime starts to go back up as the number of threads goesup (instead of down like one would expect) is a number of things. First and foremost the threadcreation may take more time than it saves here as creating threads is a very expensive process,and secondly, the problem may become not as optimal in terms of divisions as the thread countis increased.Average Speed-Up Graph:Analysis of Speed-Up Graph:This graph shows the average speedup for thread calculated by dividing the runtime ofthe sequential program by the average runtime of the threaded program. Here we get close toinitially achieving the K speed up for K threads, however, as the number of threads increasesthe non-determinism of scheduling and expense of creating threads starts to become too greatthat the runtime begins to shift back towards the sequential runtime. The parallel programalways runs faster though.Limitations of Programs:The program could potentially divide and pass to a thread when it would be cheaper todo recursion instead.Positive Aspects:Well commented additions to the program
Functional and noticeable speed-upsIf any questions contact:    Jaeden Hufnagle    jhufnagl@u.rochester.edu
